# scripts/ps/workflow/module-feature.ps1
[CmdletBinding()]
param(
  [Parameter(Mandatory = $true)] [string]$Name
)

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

$ApiRoot     = "./api"
$FeatureRoot = "./internal/feature"
$RoutesFile  = "./internal/feature/routes.go"
$utf8NoBom   = New-Object System.Text.UTF8Encoding($false)

# --- utils (logs) ---
try { . (Join-Path $PSScriptRoot 'utils.ps1') } catch {
  function Show-Step { param([string]$Message) Write-Host "`n==> $Message" -ForegroundColor Cyan }
  function Show-Info { param([string]$Message) Write-Host "$Message" -ForegroundColor DarkGray }
  function Show-OK   { param([string]$Message) Write-Host "  [OK] $Message" -ForegroundColor Green }
  function Show-Warn { param([string]$Message) Write-Host "  [WARN] $Message" -ForegroundColor Yellow }
  function Show-ErrorAndExit { param([string]$Message) Write-Host "  [ERROR] $Message" -ForegroundColor Red; exit 1 }
}

function ConvertTo-PascalCase { param([string]$s)
  # Special handling for names ending with numbers
  if ($s -match '^([a-zA-Z]+)(\d+)$') {
    $text = $Matches[1]
    $number = $Matches[2]
    return $text.Substring(0,1).ToUpper() + $text.Substring(1).ToLower() + $number
  }
  # Regular pascal case for other names
  $parts = ($s -replace '[^A-Za-z0-9]+',' ') -split '\s+' | Where-Object { $_ }
  ($parts | ForEach-Object { $_.Substring(0,1).ToUpper() + $_.Substring(1).ToLower() }) -join ''
}
function ConvertTo-LowerCase { param([string]$s) $s.ToLower() }
function ConvertTo-ImportAlias { param([string]$s) ($s.ToLower() -replace '[^a-z0-9]','_') }

Show-Step "Generating feature module (register.go, wire.go, roles.go)"

$base   = ConvertTo-LowerCase $Name            # e.g. "prueba"
$pascal = ConvertTo-PascalCase $Name           # "Prueba"
$pkg    = ($base -replace '[^a-z0-9]','_')
$alias  = ConvertTo-ImportAlias $base
# For protoc-generated names, we need to handle version differently based on name
$script:versionPrefix = if ($Name -match '^\D+\d+$') { "V" } else { "v" }
Show-Info "Module: base='$base', pascal='$pascal', pkg='$pkg', alias='$alias', version-prefix='$versionPrefix'"

# --- latest API version (vN) ---
$apiBaseDir = Join-Path $ApiRoot $base
$apiV = 1
Show-Info "Detecting latest API version in '$apiBaseDir'..."
if (Test-Path $apiBaseDir) {
  $max = 0
  Get-ChildItem $apiBaseDir -Directory -ea SilentlyContinue | ForEach-Object {
    if ($_.Name -match '^v(\d+)$') { $n=[int]$Matches[1]; if ($n -gt $max){$max=$n} }
  }
  if ($max -gt 0) { $apiV = $max }
  Show-Info "Using API version: v$apiV"
} else {
  Show-Warn "API dir not found: $apiBaseDir ; using v1."
}

# feature path uses same vN as API
$featRootV = Join-Path (Join-Path $FeatureRoot $base) "v$apiV"
$svcDir  = Join-Path $featRootV "service"
$bizDir  = Join-Path $featRootV "biz"
$repoDir = Join-Path $featRootV "repo"

Show-Info "Ensuring feature directories:"
$null = New-Item -ItemType Directory -Force -Path $svcDir, $bizDir, $repoDir
Show-OK "Created/exists: $featRootV (service, biz, repo)"

$apiImport  = "service/api/$base/v$apiV"
$svcImport  = "service/internal/feature/$base/v$apiV/service"
$bizImport  = "service/internal/feature/$base/v$apiV/biz"
$repoImport = "service/internal/feature/$base/v$apiV/repo"

# -------------------------
# register.go (module-local types + registrars) — with version in service name
# -------------------------
$registerPath = Join-Path $featRootV "register.go"
if (-not (Test-Path $registerPath)) {
  Show-Info "Writing: $registerPath"
$registerGo = @"
package $pkg

import (
	api_$alias "$apiImport"
	${pkg}_service "$svcImport"

	"github.com/go-kratos/kratos/v2/transport/grpc"
	"github.com/go-kratos/kratos/v2/transport/http"
)

// Module-local types to avoid wire type collisions
type HTTPRegister func(*http.Server)
type GRPCRegister func(*grpc.Server)

// NOTE: versioned service interfaces from proto: ${pascal}${versionPrefix}${apiV}Service...
var _ api_$alias.${pascal}${versionPrefix}${apiV}ServiceHTTPServer = (*${pkg}_service.${pascal}Service)(nil)
var _ api_$alias.${pascal}${versionPrefix}${apiV}ServiceServer     = (*${pkg}_service.${pascal}Service)(nil)

func New${pascal}HTTPRegistrer(s api_$alias.${pascal}${versionPrefix}${apiV}ServiceHTTPServer) HTTPRegister {
	return func(srv *http.Server) {
		api_$alias.Register${pascal}${versionPrefix}${apiV}ServiceHTTPServer(srv, s)
	}
}

func New${pascal}GRPCRegistrer(s api_$alias.${pascal}${versionPrefix}${apiV}ServiceServer) GRPCRegister {
	return func(srv *grpc.Server) {
		api_$alias.Register${pascal}${versionPrefix}${apiV}ServiceServer(srv, s)
	}
}
"@
  [IO.File]::WriteAllText($registerPath, $registerGo, $utf8NoBom)
  Show-OK "Created: register.go"
} else {
  Show-Info "Skip (exists): $registerPath"
}

# -------------------------
# roles.go (authz roles + endpoints) — generated by feature name + version
# -------------------------
$rolesPath = Join-Path $featRootV "roles.go"
if (-not (Test-Path $rolesPath)) {
  Show-Info "Writing: $rolesPath"

  # Group name with version: examplev1, usersv2, ...
  $groupName = "$base" + "v$apiV"

$rolesGo = @"
package $pkg

import (
	${pkg}_service "$svcImport"
	"service/internal/server/middleware/auth/authz/endpoint"
)

const (
	RoleExample = "TEST1"
)

// Endpoints with required roles (versioned)
func Get${pascal}v${apiV}Endpoints(svc *${pkg}_service.${pascal}Service) endpoint.ServiceGroup {
	return endpoint.ServiceGroup{
		Name: "$groupName",
		Methods: []endpoint.ServiceMethod{
			// Examples (uncomment and replace with real service methods):
			// endpoint.NewServiceMethod(svc, svc.List${pascal}s),
			// endpoint.NewServiceMethod(svc, svc.UpsertExcel, RoleExample),
			// other methods...
		},
	}
}

// Backward-compatible alias (without version): calls versioned function
func GetServiceEndpoints(svc *${pkg}_service.${pascal}Service) endpoint.ServiceGroup {
	return Get${pascal}v${apiV}Endpoints(svc)
}
"@

  [IO.File]::WriteAllText($rolesPath, $rolesGo, $utf8NoBom)
  Show-OK "Created: roles.go"
} else {
  Show-Info "Skip (exists): $rolesPath"
}

# -------------------------
# wire.go (ProviderSet + binds) — with version in service name
# -------------------------
$wirePath = Join-Path $featRootV "wire.go"
if (-not (Test-Path $wirePath)) {
  Show-Info "Writing: $wirePath"
$wireGo = @"
package $pkg

import (
	api_$alias "$apiImport"
	${pkg}_biz "$bizImport"
	${pkg}_repo "$repoImport"
	${pkg}_service "$svcImport"

	"github.com/google/wire"
)

var ProviderSet = wire.NewSet(
	${pkg}_repo.New${pascal}Repo,
	${pkg}_biz.New${pascal}Usecase,
	${pkg}_service.New${pascal}Service,

	// map generated service interfaces (versioned) to our implementation
	wire.Bind(new(api_$alias.${pascal}${versionPrefix}${apiV}ServiceHTTPServer), new(*${pkg}_service.${pascal}Service)),
	wire.Bind(new(api_$alias.${pascal}${versionPrefix}${apiV}ServiceServer),     new(*${pkg}_service.${pascal}Service)),

	// module-local registrars
	New${pascal}HTTPRegistrer,
	New${pascal}GRPCRegistrer,
)
"@
  [IO.File]::WriteAllText($wirePath, $wireGo, $utf8NoBom)
  Show-OK "Created: wire.go"
} else {
  Show-Info "Skip (exists): $wirePath"
}

# --- update routes.go ---
if (-not (Test-Path -LiteralPath $RoutesFile)) {
  Show-Warn "File not found: $RoutesFile (creating new one)"
  $baseAlias = "${base}_v${apiV}"
  $routesGo = "package feature

import (
	""service/internal/server/middleware/auth/authz/endpoint""
	${baseAlias} ""service/internal/feature/${base}/v${apiV}""
	${baseAlias}_service ""service/internal/feature/${base}/v${apiV}/service""

	""github.com/google/wire""
)

// ProvideAuthGroups get all groups of services who requires authentication and authorization
func ProvideAuthGroups(
	${base}V${apiV}Svc *${baseAlias}_service.${pascal}Service,

	// Add other services there
) []endpoint.ServiceGroup {
	return []endpoint.ServiceGroup{
		${baseAlias}.GetServiceEndpoints(${base}V${apiV}Svc),
	}
}

var ProviderAuthSet = wire.NewSet(ProvideAuthGroups)
".Replace('""', '"')
  [IO.File]::WriteAllText($RoutesFile, $routesGo, $utf8NoBom)
  Show-OK "Created: $RoutesFile"
} else {
  Show-Step "Updating routes in $RoutesFile"
  $txt = Get-Content -LiteralPath $RoutesFile -Raw -Encoding UTF8

  # Check if imports section exists
  if (-not ($txt -match '(?m)^import\s*\(\s*$')) {
    Show-ErrorAndExit "Invalid routes.go format: import section not found"
  }

  # Add imports if not exist
  $baseAlias = "${base}_v${apiV}"
  $importBase = "${baseAlias} ""service/internal/feature/${base}/v${apiV}"""
  $importService = "${baseAlias}_service ""service/internal/feature/${base}/v${apiV}/service"""
  
  if (-not ($txt -match [regex]::Escape($importBase))) {
    $txt = $txt -replace '(?m)(^import\s*\(\s*$)', "`$1`n`t$importBase"
  }
  if (-not ($txt -match [regex]::Escape($importService))) {
    $txt = $txt -replace '(?m)(^import\s*\(\s*$)', "`$1`n`t$importService"
  }

  # Add parameter if not exists
  $paramLine = "${base}V${apiV}Svc *${baseAlias}_service.${pascal}Service,"
  if (-not ($txt -match [regex]::Escape($paramLine))) {
    $txt = $txt -replace '(?m)(^func\s+ProvideAuthGroups\s*\()([^\)]*)\)', "`$1`n`t$paramLine`$2)"
  }

  # Add group if not exists
  if (-not ($txt -match [regex]::Escape("${baseAlias}.GetServiceEndpoints(${base}V${apiV}Svc)"))) {
    # Check if there are any existing endpoints (ignoring comments)
    if ($txt -match '(?m)return\s+\[\]endpoint\.ServiceGroup\s*\{\s*(?://[^\n]*\n\s*)*\}') {
      # Empty group (only comments) - add as first item
      $txt = $txt -replace '(?m)(return\s+\[\]endpoint\.ServiceGroup\s*\{\s*(?://[^\n]*\n\s*)*)\}', "`$1`n`t`t${baseAlias}.GetServiceEndpoints(${base}V${apiV}Svc),`n`t}"
    } elseif ($txt -match '(?m)(return\s+\[\]endpoint\.ServiceGroup\s*\{[^\}]*?)((?:\s*//[^\n]*)*\s*)\}') {
      # Has other items - add with comma
      $current = $Matches[0]
      $prefix = $Matches[1]
      $suffix = $Matches[2]
      
      # Remove trailing comma from the last item if exists
      $prefix = $prefix -replace ',\s*$', ''
      # Add new item with comma
      $txt = $txt -replace [regex]::Escape($current), "${prefix},`n`t`t${baseAlias}.GetServiceEndpoints(${base}V${apiV}Svc),${suffix}}"
    }
    
    # Fix any double tabs that might have been created
    $txt = $txt -replace '\t\t\t', "`t`t"
  }
  }

  # Save changes
  [IO.File]::WriteAllText($RoutesFile, $txt, $utf8NoBom)
  Show-OK "Updated: $RoutesFile" 


Show-OK ("feature module generated: {0}/v{1}  (register.go, wire.go, roles.go, routes.go)" -f $base, $apiV)